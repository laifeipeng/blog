(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{317:function(t,a,r){"use strict";r.r(a);var s=r(2),v=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"javascript中的名词概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#javascript中的名词概念"}},[t._v("#")]),t._v(" JavaScript中的名词概念")]),t._v(" "),r("h2",{attrs:{id:"什么是作用域？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是作用域？"}},[t._v("#")]),t._v(" 什么是作用域？")]),t._v(" "),r("p",[t._v("变量存在的范围。可分为全局作用域和函数作用域，ES6新增块级作用域。")]),t._v(" "),r("h2",{attrs:{id:"什么是闭包？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是闭包？"}},[t._v("#")]),t._v(" 什么是闭包？")]),t._v(" "),r("p",[t._v("闭包就是能够读取其他函数内部变量的函数。")]),t._v(" "),r("ul",[r("li",[t._v("闭包的形式：函数内部定义函数")]),t._v(" "),r("li",[t._v("本质上闭包就是将函数内部和外部连接起来的一座桥梁")])]),t._v(" "),r("p",[t._v("闭包的作用：")]),t._v(" "),r("ul",[r("li",[t._v("可以读取函数内部变量")]),t._v(" "),r("li",[t._v("让这些变量始终保持在内存中，即闭包可以使得它诞生的环境一直存在。")]),t._v(" "),r("li",[t._v("封装对象的私有属性和私有方法")])]),t._v(" "),r("h2",{attrs:{id:"什么是构造函数？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是构造函数？"}},[t._v("#")]),t._v(" 什么是构造函数？")]),t._v(" "),r("p",[t._v("用于构造(生成)实例的一个函数，使实例拥有构造函数内定于的属性和方法。")]),t._v(" "),r("h2",{attrs:{id:"什么是实例对象？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是实例对象？"}},[t._v("#")]),t._v(" 什么是实例对象？")]),t._v(" "),r("p",[t._v("实例对象就是通过new 构造函数生成的，拥有构造函数内定于的属性和方法的一个对象。")]),t._v(" "),r("h2",{attrs:{id:"什么是this？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是this？"}},[t._v("#")]),t._v(" 什么是this？")]),t._v(" "),r("p",[t._v("就是属性或方法当前所在的对象，指向当前运行环境（对象）")]),t._v(" "),r("h2",{attrs:{id:"什么是原型？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是原型？"}},[t._v("#")]),t._v(" 什么是原型？")]),t._v(" "),r("p",[t._v("每个函数都有一个prototype属性，指向一个对象，该对象称为原型对象。")]),t._v(" "),r("h2",{attrs:{id:"什么是原型链？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是原型链？"}},[t._v("#")]),t._v(" 什么是原型链？")]),t._v(" "),r("p",[t._v("所有对象都有自己的原型对象，由于原型对象也是对象，因此它也有自己的原型，这就会形成一个原型链。")]),t._v(" "),r("p",[t._v("最顶层的原型是Object.prototype。")]),t._v(" "),r("blockquote",[r("p",[t._v("读取对象属性时，JS会先在对象自身上找，找到就直接返回，如果找不到，会到原型上找，如果还是找不到，就会去原型的原型上找，最终会到最顶层的Object.prototype上找，还是找不到就会返回undefined。")])]),t._v(" "),r("h2",{attrs:{id:"什么是constructor？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是constructor？"}},[t._v("#")]),t._v(" 什么是constructor？")]),t._v(" "),r("p",[t._v("prototype原型对象都有一个constructor属性，默认指向prototype对象所在的构造函数。")]),t._v(" "),r("h2",{attrs:{id:"什么是包装对象？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是包装对象？"}},[t._v("#")]),t._v(" 什么是包装对象？")]),t._v(" "),r("p",[t._v("包装对象指的是将原始类型（数字、字符串、布尔值）进行实例化。")])])}),[],!1,null,null,null);a.default=v.exports}}]);